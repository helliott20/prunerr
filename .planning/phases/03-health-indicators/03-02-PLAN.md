---
phase: 03-health-indicators
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - client/src/types/index.ts
  - client/src/services/api.ts
  - client/src/hooks/useApi.ts
  - client/src/components/Health/ServiceStatusIndicator.tsx
  - client/src/components/Health/SystemHealthCard.tsx
  - client/src/components/Health/ScheduleInfoCard.tsx
  - client/src/components/Dashboard/Dashboard.tsx
autonomous: true

must_haves:
  truths:
    - "User sees colored status dots for each service (green=connected, red=disconnected, gray=not configured)"
    - "User sees last scan timestamp displayed on dashboard"
    - "User sees next scheduled run time displayed on dashboard"
    - "Health status automatically refreshes every 30 seconds"
  artifacts:
    - path: "client/src/components/Health/ServiceStatusIndicator.tsx"
      provides: "Individual service status display with dot and label"
      min_lines: 30
    - path: "client/src/components/Health/SystemHealthCard.tsx"
      provides: "Card showing all service statuses"
      min_lines: 40
    - path: "client/src/components/Health/ScheduleInfoCard.tsx"
      provides: "Card showing last scan and next run"
      min_lines: 30
    - path: "client/src/hooks/useApi.ts"
      provides: "useHealthStatus hook with 30s polling"
      contains: "refetchInterval"
  key_links:
    - from: "client/src/hooks/useApi.ts"
      to: "client/src/services/api.ts"
      via: "healthApi.getStatus"
      pattern: "healthApi\\.getStatus"
    - from: "client/src/components/Dashboard/Dashboard.tsx"
      to: "client/src/hooks/useApi.ts"
      via: "useHealthStatus hook"
      pattern: "useHealthStatus"
    - from: "client/src/components/Dashboard/Dashboard.tsx"
      to: "client/src/components/Health/"
      via: "component imports"
      pattern: "from '@/components/Health"
---

<objective>
Create frontend components to display health status on the dashboard, including service connection indicators, last scan timestamp, and next scheduled run time.

Purpose: Give users instant visibility into system health without navigating away from the main dashboard. Fulfills HEALTH-01, HEALTH-02, HEALTH-03 requirements.

Output: Health cards integrated into Dashboard header showing service status and scheduling info
</objective>

<execution_context>
@~/.claude/agents/gsd-executor.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-health-indicators/03-RESEARCH.md
@.planning/phases/03-health-indicators/03-01-SUMMARY.md

# Key files for this plan:
@client/src/types/index.ts
@client/src/services/api.ts
@client/src/hooks/useApi.ts
@client/src/components/Dashboard/Dashboard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add types, API, and hook for health status</name>
  <files>client/src/types/index.ts, client/src/services/api.ts, client/src/hooks/useApi.ts</files>
  <action>
1. Add types to client/src/types/index.ts (at end of file, before any closing brace):

```typescript
// Health Status Types
export interface ServiceHealthStatus {
  service: string;
  configured: boolean;
  connected: boolean;
  responseTimeMs?: number;
  error?: string;
  lastChecked: string;
}

export interface SchedulerStatus {
  isRunning: boolean;
  lastScan: string | null;
  nextRun: string | null;
  scanSchedule: string;
}

export interface SystemHealthResponse {
  services: ServiceHealthStatus[];
  scheduler: SchedulerStatus;
  overall: 'healthy' | 'degraded' | 'unhealthy';
}
```

2. Add healthApi to client/src/services/api.ts:
   - Add import for new types: `SystemHealthResponse`
   - Add new API object after activityApi:

```typescript
// Health APIs
export const healthApi = {
  getStatus: async (): Promise<SystemHealthResponse> => {
    const { data } = await api.get<ApiResponse<SystemHealthResponse>>('/health/status');
    return data.data!;
  },
};
```

3. Add hook to client/src/hooks/useApi.ts:
   - Add import for healthApi: `import { ..., healthApi } from '@/services/api';`
   - Add import for SystemHealthResponse type
   - Add query key: `healthStatus: ['health', 'status'] as const,`
   - Add hook after existing hooks:

```typescript
// Health Hooks
export function useHealthStatus() {
  return useQuery({
    queryKey: queryKeys.healthStatus,
    queryFn: healthApi.getStatus,
    refetchInterval: 30000, // Poll every 30 seconds
    refetchIntervalInBackground: false, // Stop polling when tab not visible
    staleTime: 15000, // Consider stale after 15 seconds
    retry: 1, // Only retry once on failure
  });
}
```
  </action>
  <verify>
TypeScript compilation:
```bash
cd client && npx tsc --noEmit
```
Should compile without errors.
  </verify>
  <done>HealthStatus types defined, healthApi.getStatus() exists, useHealthStatus() hook with 30s polling configured</done>
</task>

<task type="auto">
  <name>Task 2: Create Health components</name>
  <files>client/src/components/Health/ServiceStatusIndicator.tsx, client/src/components/Health/SystemHealthCard.tsx, client/src/components/Health/ScheduleInfoCard.tsx</files>
  <action>
Create the Health components directory and three components:

1. Create client/src/components/Health/ServiceStatusIndicator.tsx:

```typescript
import { cn } from '@/lib/utils';

interface ServiceStatusIndicatorProps {
  name: string;
  configured: boolean;
  connected: boolean;
  error?: string;
  loading?: boolean;
  responseTimeMs?: number;
}

export function ServiceStatusIndicator({
  name,
  configured,
  connected,
  error,
  loading,
  responseTimeMs,
}: ServiceStatusIndicatorProps) {
  const status = !configured ? 'unconfigured' : connected ? 'connected' : 'disconnected';

  const statusConfig = {
    unconfigured: {
      dotColor: 'bg-surface-500',
      textColor: 'text-surface-400',
      label: 'Not configured',
    },
    connected: {
      dotColor: 'bg-emerald-500',
      textColor: 'text-emerald-400',
      label: responseTimeMs ? `${responseTimeMs}ms` : 'Connected',
    },
    disconnected: {
      dotColor: 'bg-ruby-500',
      textColor: 'text-ruby-400',
      label: error || 'Disconnected',
    },
  };

  const config = statusConfig[status];

  return (
    <div className="flex items-center gap-2 py-1">
      <span
        className={cn(
          'w-2 h-2 rounded-full flex-shrink-0 transition-colors',
          loading ? 'bg-amber-500 animate-pulse' : config.dotColor
        )}
      />
      <span className="text-sm text-surface-200 capitalize">{name}</span>
      <span className={cn('text-xs truncate', loading ? 'text-amber-400' : config.textColor)}>
        {loading ? 'Checking...' : config.label}
      </span>
    </div>
  );
}
```

2. Create client/src/components/Health/SystemHealthCard.tsx:

```typescript
import { Activity, AlertCircle } from 'lucide-react';
import { cn } from '@/lib/utils';
import { ServiceStatusIndicator } from './ServiceStatusIndicator';
import type { ServiceHealthStatus } from '@/types';

interface SystemHealthCardProps {
  services: ServiceHealthStatus[];
  overall: 'healthy' | 'degraded' | 'unhealthy';
  loading?: boolean;
  isFetching?: boolean;
}

export function SystemHealthCard({ services, overall, loading, isFetching }: SystemHealthCardProps) {
  const overallConfig = {
    healthy: {
      color: 'text-emerald-400',
      bgColor: 'bg-emerald-500/10',
      label: 'All Systems Operational',
    },
    degraded: {
      color: 'text-amber-400',
      bgColor: 'bg-amber-500/10',
      label: 'Partial Outage',
    },
    unhealthy: {
      color: 'text-ruby-400',
      bgColor: 'bg-ruby-500/10',
      label: 'Systems Unavailable',
    },
  };

  const config = overallConfig[overall];

  // Sort services: configured first, then alphabetically
  const sortedServices = [...services].sort((a, b) => {
    if (a.configured !== b.configured) return a.configured ? -1 : 1;
    return a.service.localeCompare(b.service);
  });

  return (
    <div className="card p-4">
      <div className="flex items-center justify-between mb-3">
        <div className="flex items-center gap-2">
          <div className={cn('p-1.5 rounded-lg', config.bgColor)}>
            {overall === 'unhealthy' ? (
              <AlertCircle className={cn('w-4 h-4', config.color)} />
            ) : (
              <Activity className={cn('w-4 h-4', config.color)} />
            )}
          </div>
          <div>
            <h3 className="text-sm font-medium text-white">Service Status</h3>
            <p className={cn('text-xs', config.color)}>{config.label}</p>
          </div>
        </div>
        {isFetching && !loading && (
          <span className="text-xs text-surface-500 animate-pulse">Refreshing...</span>
        )}
      </div>

      {loading ? (
        <div className="space-y-2">
          {[...Array(5)].map((_, i) => (
            <div key={i} className="skeleton-shimmer h-6 rounded" />
          ))}
        </div>
      ) : (
        <div className="space-y-0.5">
          {sortedServices.map((service) => (
            <ServiceStatusIndicator
              key={service.service}
              name={service.service}
              configured={service.configured}
              connected={service.connected}
              error={service.error}
              responseTimeMs={service.responseTimeMs}
              loading={isFetching}
            />
          ))}
        </div>
      )}
    </div>
  );
}
```

3. Create client/src/components/Health/ScheduleInfoCard.tsx:

```typescript
import { Clock, Calendar, PlayCircle, AlertTriangle } from 'lucide-react';
import { cn, formatRelativeTime } from '@/lib/utils';
import type { SchedulerStatus } from '@/types';

interface ScheduleInfoCardProps {
  scheduler: SchedulerStatus;
  loading?: boolean;
}

export function ScheduleInfoCard({ scheduler, loading }: ScheduleInfoCardProps) {
  // Format the cron schedule for display
  const formatSchedule = (cron: string): string => {
    // Common patterns
    if (cron === '0 3 * * *') return 'Daily at 3:00 AM';
    if (cron === '0 4 * * *') return 'Daily at 4:00 AM';
    if (cron === '0 * * * *') return 'Every hour';
    if (cron.startsWith('*/')) {
      const minutes = cron.split(' ')[0]?.replace('*/', '');
      return `Every ${minutes} minutes`;
    }
    // Default: show raw cron
    return cron;
  };

  return (
    <div className="card p-4">
      <div className="flex items-center gap-2 mb-3">
        <div className="p-1.5 rounded-lg bg-accent-500/10">
          <Clock className="w-4 h-4 text-accent-400" />
        </div>
        <div>
          <h3 className="text-sm font-medium text-white">Schedule</h3>
          <p className="text-xs text-surface-500">{formatSchedule(scheduler.scanSchedule)}</p>
        </div>
      </div>

      {loading ? (
        <div className="space-y-3">
          <div className="skeleton-shimmer h-10 rounded" />
          <div className="skeleton-shimmer h-10 rounded" />
        </div>
      ) : (
        <div className="space-y-3">
          {/* Last Scan */}
          <div className="flex items-center gap-3 p-2.5 rounded-lg bg-surface-800/50">
            <PlayCircle className="w-4 h-4 text-surface-400 flex-shrink-0" />
            <div className="min-w-0 flex-1">
              <p className="text-xs text-surface-500">Last Scan</p>
              {scheduler.lastScan ? (
                <p className="text-sm text-surface-200 truncate">
                  {formatRelativeTime(scheduler.lastScan)}
                </p>
              ) : (
                <p className="text-sm text-surface-500 italic">Never run</p>
              )}
            </div>
          </div>

          {/* Next Run */}
          <div className="flex items-center gap-3 p-2.5 rounded-lg bg-surface-800/50">
            <Calendar className="w-4 h-4 text-surface-400 flex-shrink-0" />
            <div className="min-w-0 flex-1">
              <p className="text-xs text-surface-500">Next Scheduled</p>
              {scheduler.isRunning && scheduler.nextRun ? (
                <p className="text-sm text-surface-200 truncate">
                  {formatRelativeTime(scheduler.nextRun)}
                </p>
              ) : !scheduler.isRunning ? (
                <div className="flex items-center gap-1 text-amber-400">
                  <AlertTriangle className="w-3 h-3" />
                  <span className="text-sm">Scheduler stopped</span>
                </div>
              ) : (
                <p className="text-sm text-surface-500 italic">Not scheduled</p>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
```
  </action>
  <verify>
TypeScript compilation:
```bash
cd client && npx tsc --noEmit
```
Should compile without errors.
  </verify>
  <done>Three Health components created: ServiceStatusIndicator, SystemHealthCard, ScheduleInfoCard</done>
</task>

<task type="auto">
  <name>Task 3: Integrate health cards into Dashboard</name>
  <files>client/src/components/Dashboard/Dashboard.tsx</files>
  <action>
Update Dashboard.tsx to display health status:

1. Add imports at top:
```typescript
import { useHealthStatus } from '@/hooks/useApi';
import { SystemHealthCard } from '@/components/Health/SystemHealthCard';
import { ScheduleInfoCard } from '@/components/Health/ScheduleInfoCard';
```

2. Inside Dashboard component, add the health status hook (after existing hooks like useStats):
```typescript
const { data: healthStatus, isLoading: healthLoading, isFetching: healthFetching } = useHealthStatus();
```

3. Replace the hardcoded "Last scan: 2 hours ago" in the header (currently around line 67-70) with dynamic content. Find this block:
```tsx
<div className="hidden lg:flex items-center gap-3 text-sm text-surface-400">
  <Calendar className="w-4 h-4" />
  Last scan: <span className="text-surface-200 font-medium">2 hours ago</span>
</div>
```

Replace it with:
```tsx
<div className="hidden lg:flex items-center gap-3 text-sm text-surface-400">
  <Calendar className="w-4 h-4" />
  Last scan:{' '}
  <span className="text-surface-200 font-medium">
    {healthLoading ? '...' : healthStatus?.scheduler.lastScan
      ? formatRelativeTime(healthStatus.scheduler.lastScan)
      : 'Never'}
  </span>
</div>
```

4. Add a new section after the header and before the critical error check (around line 75). Insert new health status cards grid:
```tsx
{/* Health Status Row */}
{!hasCriticalError && (
  <div className="grid grid-cols-1 lg:grid-cols-2 gap-5">
    <SystemHealthCard
      services={healthStatus?.services || []}
      overall={healthStatus?.overall || 'unhealthy'}
      loading={healthLoading}
      isFetching={healthFetching}
    />
    <ScheduleInfoCard
      scheduler={healthStatus?.scheduler || {
        isRunning: false,
        lastScan: null,
        nextRun: null,
        scanSchedule: '0 3 * * *',
      }}
      loading={healthLoading}
    />
  </div>
)}
```

This places the health cards in a prominent position at the top of the dashboard, after the header but before the stats grid.
  </action>
  <verify>
1. TypeScript compilation:
```bash
cd client && npx tsc --noEmit
```

2. Visual verification:
- Start both server and client
- Open dashboard at http://localhost:5173
- Should see Service Status card with colored dots for each service
- Should see Schedule card with Last Scan and Next Scheduled times
- Header should show dynamic "Last scan: X ago" instead of hardcoded "2 hours ago"
- Status should refresh every 30 seconds (watch network tab)
  </verify>
  <done>Health cards integrated into Dashboard, showing service status, last scan, and next run times</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors for both client and server
2. Dashboard displays Service Status card with all 5 services
3. Each service shows appropriate color: emerald (connected), ruby (disconnected), gray (not configured)
4. Dashboard displays Schedule card with Last Scan and Next Scheduled times
5. Header shows dynamic "Last scan: X ago" timestamp
6. Network tab shows /api/health/status calls every 30 seconds
7. When tab is not visible, polling stops (check by switching tabs and watching network)
</verification>

<success_criteria>
- User sees connection status for all integrated services (HEALTH-01)
- User sees last scan timestamp on dashboard (HEALTH-02)
- User sees next scheduled run time on dashboard (HEALTH-03)
- Health status auto-refreshes every 30 seconds without manual action
</success_criteria>

<output>
After completion, create `.planning/phases/03-health-indicators/03-02-SUMMARY.md`
</output>
