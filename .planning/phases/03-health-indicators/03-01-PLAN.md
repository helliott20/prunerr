---
phase: 03-health-indicators
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/package.json
  - server/src/scheduler/index.ts
  - server/src/routes/health.ts
autonomous: true

must_haves:
  truths:
    - "API returns connection status for all 5 services (Plex, Radarr, Sonarr, Tautulli, Overseerr)"
    - "API returns last scan timestamp from scan_history table"
    - "API returns next scheduled run time calculated from cron expression"
    - "Service checks run in parallel (not sequential)"
  artifacts:
    - path: "server/src/routes/health.ts"
      provides: "GET /api/health/status endpoint"
      exports: ["router"]
    - path: "server/src/scheduler/index.ts"
      provides: "Accurate next-run calculation using cron-parser"
      contains: "cron-parser"
  key_links:
    - from: "server/src/routes/health.ts"
      to: "services/*.ts"
      via: "testConnection() calls"
      pattern: "testConnection\\(\\)"
    - from: "server/src/routes/health.ts"
      to: "scheduler/index.ts"
      via: "getScheduler().getJobStatus()"
      pattern: "getJobStatus"
    - from: "server/src/routes/health.ts"
      to: "db/repositories/scanHistoryRepo.ts"
      via: "scanHistoryRepo.getLatest()"
      pattern: "getLatest\\(\\)"
---

<objective>
Create the backend health status endpoint that aggregates service connection tests, scheduler status, and scan history into a single API response.

Purpose: Provide all health data in one request for dashboard display. Services already have testConnection() methods; this endpoint exposes them alongside scheduler timing info.

Output: GET /api/health/status endpoint returning ServiceHealthStatus[], scheduler info, and overall health
</objective>

<execution_context>
@~/.claude/agents/gsd-executor.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-health-indicators/03-RESEARCH.md

# Key files for this plan:
@server/src/routes/health.ts
@server/src/scheduler/index.ts
@server/src/services/plex.ts (testConnection pattern)
@server/src/db/repositories/scanHistoryRepo.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install cron-parser and upgrade scheduler</name>
  <files>server/package.json, server/src/scheduler/index.ts</files>
  <action>
1. Install cron-parser in server directory:
   ```bash
   cd server && npm install cron-parser
   ```

2. Update server/src/scheduler/index.ts:
   - Add import: `import { CronExpressionParser } from 'cron-parser';`
   - Replace the simplified `getNextRunTime()` method (currently lines 349-389) with a proper implementation using cron-parser:

```typescript
/**
 * Calculate next run time from cron expression using cron-parser
 */
private getNextRunTime(cronExpression: string): Date | undefined {
  if (!cronExpression || !cron.validate(cronExpression)) {
    return undefined;
  }

  try {
    const options = {
      currentDate: new Date(),
      tz: this.config.timezone,
    };

    const interval = CronExpressionParser.parse(cronExpression, options);
    return interval.next().toDate();
  } catch (error) {
    logger.error('Failed to parse cron expression', { cronExpression, error });
    return undefined;
  }
}
```

This replaces the simplified date math with proper cron parsing that handles DST, month boundaries, and complex expressions.
  </action>
  <verify>
Run TypeScript compilation:
```bash
cd server && npx tsc --noEmit
```
Should compile without errors.
  </verify>
  <done>cron-parser installed, getNextRunTime uses cron-parser for accurate next-run calculation</done>
</task>

<task type="auto">
  <name>Task 2: Create aggregated health status endpoint</name>
  <files>server/src/routes/health.ts</files>
  <action>
Extend the existing health.ts router with a new GET /status endpoint that:

1. Add imports at top of file:
```typescript
import { getScheduler } from '../scheduler';
import * as scanHistoryRepo from '../db/repositories/scanHistoryRepo';
import { getPlexService, getRadarrService, getSonarrService, getTautulliService, getOverseerrService } from '../services/init';
```

2. Add type definitions:
```typescript
interface ServiceHealthStatus {
  service: string;
  configured: boolean;
  connected: boolean;
  responseTimeMs?: number;
  error?: string;
  lastChecked: string;
}

interface SchedulerStatus {
  isRunning: boolean;
  lastScan: string | null;
  nextRun: string | null;
  scanSchedule: string;
}

interface SystemHealthResponse {
  services: ServiceHealthStatus[];
  scheduler: SchedulerStatus;
  overall: 'healthy' | 'degraded' | 'unhealthy';
}
```

3. Add helper function for parallel service checks with timeout:
```typescript
async function checkService(name: string, service: { testConnection: () => Promise<boolean> } | null): Promise<ServiceHealthStatus> {
  const lastChecked = new Date().toISOString();

  if (!service) {
    return { service: name, configured: false, connected: false, lastChecked };
  }

  const startTime = Date.now();
  try {
    // Race the connection test against a 5-second timeout
    const connected = await Promise.race([
      service.testConnection(),
      new Promise<boolean>((_, reject) =>
        setTimeout(() => reject(new Error('Connection timeout')), 5000)
      ),
    ]);

    return {
      service: name,
      configured: true,
      connected,
      responseTimeMs: Date.now() - startTime,
      lastChecked,
    };
  } catch (error) {
    return {
      service: name,
      configured: true,
      connected: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      responseTimeMs: Date.now() - startTime,
      lastChecked,
    };
  }
}

function determineOverallHealth(services: ServiceHealthStatus[]): 'healthy' | 'degraded' | 'unhealthy' {
  const configuredServices = services.filter(s => s.configured);
  if (configuredServices.length === 0) return 'unhealthy';

  const connectedCount = configuredServices.filter(s => s.connected).length;
  if (connectedCount === configuredServices.length) return 'healthy';
  if (connectedCount > 0) return 'degraded';
  return 'unhealthy';
}
```

4. Add the new endpoint (before the export):
```typescript
// Aggregated health status for dashboard
router.get('/status', async (_req: Request, res: Response) => {
  try {
    // Run all service checks in parallel
    const serviceChecks = await Promise.allSettled([
      checkService('plex', getPlexService()),
      checkService('radarr', getRadarrService()),
      checkService('sonarr', getSonarrService()),
      checkService('tautulli', getTautulliService()),
      checkService('overseerr', getOverseerrService()),
    ]);

    const services: ServiceHealthStatus[] = serviceChecks.map((result, index) => {
      const serviceNames = ['plex', 'radarr', 'sonarr', 'tautulli', 'overseerr'];
      if (result.status === 'fulfilled') {
        return result.value;
      }
      return {
        service: serviceNames[index] || 'unknown',
        configured: false,
        connected: false,
        error: result.reason instanceof Error ? result.reason.message : 'Check failed',
        lastChecked: new Date().toISOString(),
      };
    });

    // Get scheduler info
    const scheduler = getScheduler();
    const scanJobStatus = scheduler.getJobStatus('scanLibraries');
    const schedulerConfig = scheduler.getConfig();

    // Get last scan from history
    const latestScan = scanHistoryRepo.getLatest();

    const response: SystemHealthResponse = {
      services,
      scheduler: {
        isRunning: scheduler.isSchedulerRunning(),
        lastScan: latestScan?.completed_at || latestScan?.started_at || null,
        nextRun: scanJobStatus?.nextRun?.toISOString() || null,
        scanSchedule: schedulerConfig.schedules.scanLibraries,
      },
      overall: determineOverallHealth(services),
    };

    res.json({ success: true, data: response });
  } catch (error) {
    logger.error('Health status check failed:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to check system health',
    });
  }
});
```

IMPORTANT: Use Promise.allSettled (not Promise.all) so one failing service doesn't break the entire health check.
  </action>
  <verify>
1. Compile check:
```bash
cd server && npx tsc --noEmit
```

2. Start server and test endpoint:
```bash
curl http://localhost:3001/api/health/status | jq .
```

Expected response structure:
```json
{
  "success": true,
  "data": {
    "services": [
      {"service": "plex", "configured": true, "connected": true, ...},
      ...
    ],
    "scheduler": {
      "isRunning": true,
      "lastScan": "2026-01-22T...",
      "nextRun": "2026-01-23T03:00:00.000Z",
      "scanSchedule": "0 3 * * *"
    },
    "overall": "healthy"
  }
}
```
  </verify>
  <done>GET /api/health/status returns service statuses, scheduler info, and overall health in a single response</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. GET /api/health/status returns JSON with services array, scheduler object, and overall status
3. Each service in array has: service name, configured boolean, connected boolean, optional responseTimeMs/error
4. Scheduler object has: isRunning, lastScan (ISO string or null), nextRun (ISO string or null), scanSchedule
5. Response time for endpoint < 10 seconds (parallel execution, not 5*5s sequential)
</verification>

<success_criteria>
- cron-parser installed and used for accurate next-run calculation
- /api/health/status endpoint exists and returns complete health data
- Service checks run in parallel with 5-second timeout per service
- Response includes configured vs connected distinction for each service
</success_criteria>

<output>
After completion, create `.planning/phases/03-health-indicators/03-01-SUMMARY.md`
</output>
