---
phase: 05-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/notifications/index.ts
  - server/src/notifications/templates.ts
  - server/src/scheduler/tasks.ts
  - server/src/routes/settings.ts
  - client/src/components/Settings/Settings.tsx
autonomous: true

must_haves:
  truths:
    - "User can configure a Discord webhook URL in settings"
    - "User can test Discord notification from settings UI"
    - "User receives Discord notification when library scan completes"
    - "User receives Discord notification when scan or deletion fails"
  artifacts:
    - path: "server/src/notifications/index.ts"
      provides: "Settings-driven Discord webhook configuration"
      contains: "settingsRepo.getValue"
    - path: "server/src/notifications/templates.ts"
      provides: "Error notification templates"
      contains: "SCAN_ERROR"
    - path: "server/src/routes/settings.ts"
      provides: "Test notification endpoint"
      contains: "/test/discord"
    - path: "client/src/components/Settings/Settings.tsx"
      provides: "Test notification button"
      contains: "Test Notification"
  key_links:
    - from: "server/src/notifications/index.ts"
      to: "settingsRepo"
      via: "import and getValue call"
      pattern: "settingsRepo\\.getValue.*notifications_discord"
    - from: "server/src/scheduler/tasks.ts"
      to: "notificationService.notify"
      via: "error notification in catch blocks"
      pattern: "notify.*SCAN_ERROR|DELETION_ERROR"
---

<objective>
Wire Discord notifications to database settings and add error notifications

Purpose: Enable users to configure Discord notifications via the Settings UI (already built in Phase 4) and receive alerts for both successful scans and errors. The notification service infrastructure exists but currently reads from environment variables - this plan connects it to database settings.

Output: Working Discord notifications triggered by scan completions, scan errors, and deletion errors. Test button in Settings UI allows users to verify their webhook configuration works.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-notifications/05-RESEARCH.md
@.planning/phases/04-settings/04-05-SUMMARY.md

# Existing notification service (read for context)
@server/src/notifications/index.ts
@server/src/notifications/templates.ts
@server/src/scheduler/tasks.ts
@server/src/routes/settings.ts
@client/src/components/Settings/Settings.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire NotificationService to database settings</name>
  <files>server/src/notifications/index.ts</files>
  <action>
  Modify NotificationService.notify() to read Discord webhook URL from database settings at send time, not at construction time. This ensures changes to webhook URL take effect immediately without service restart.

  1. Add import at top of file:
     ```typescript
     import settingsRepo from '../db/repositories/settings';
     ```

  2. In the notify() method, replace the Discord sending block (around line 136-154) to read settings dynamically:
     ```typescript
     // Send Discord notification - read settings at notification time
     const discordEnabled = settingsRepo.getBoolean('notifications_discordEnabled', false);
     const discordWebhook = settingsRepo.getValue('notifications_discordWebhook') || config.discord.webhookUrl;

     if (discordEnabled && discordWebhook) {
       try {
         const message = getDiscordMessage(notificationEvent, data);
         const result = await this.sendDiscord(discordWebhook, message);
         results.push({
           channel: 'discord',
           success: result,
           error: result ? undefined : 'Failed to send Discord message',
         });
       } catch (error) {
         const errorMessage = error instanceof Error ? error.message : String(error);
         logger.error('Discord notification error:', error);
         results.push({
           channel: 'discord',
           success: false,
           error: errorMessage,
         });
       }
     }
     ```

  3. Remove the constructor's reliance on isServiceConfigured('discord') for Discord enabled state - let settings control it.

  Key changes:
  - Read `notifications_discordEnabled` and `notifications_discordWebhook` at send time
  - Fall back to `config.discord.webhookUrl` for backward compatibility with env vars
  - Settings take precedence over environment configuration
  </action>
  <verify>
  TypeScript compiles: `cd /home/harry/projects/library-manager && npx tsc --noEmit -p server/tsconfig.json`
  </verify>
  <done>
  NotificationService reads Discord webhook URL from database settings at notification time. Changes to webhook URL in Settings UI take effect on next notification without restart.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add error notification event types and templates</name>
  <files>server/src/notifications/templates.ts</files>
  <action>
  Add SCAN_ERROR and DELETION_ERROR notification events with templates for Discord, plain text, and email.

  1. Add to NotificationEvent type (around line 546):
     ```typescript
     export type NotificationEvent =
       | 'ITEMS_MARKED'
       | 'DELETION_IMMINENT'
       | 'DELETION_COMPLETE'
       | 'SCAN_COMPLETE'
       | 'SCAN_ERROR'
       | 'DELETION_ERROR';
     ```

  2. Add data interfaces after existing interfaces (around line 60):
     ```typescript
     export interface ScanErrorData {
       error: string;
       phase: 'scanning' | 'evaluating' | 'persisting';
       itemsScannedBeforeError?: number;
       timestamp: string;
     }

     export interface DeletionErrorData {
       error: string;
       itemsProcessedBeforeError: number;
       failedItemTitle?: string;
       timestamp: string;
     }
     ```

  3. Add plain text templates (after getScanCompleteText):
     ```typescript
     export function getScanErrorText(data: ScanErrorData): string {
       return (
         `[Prunerr] Scan Failed\n\n` +
         `Error during ${data.phase}: ${data.error}\n` +
         (data.itemsScannedBeforeError
           ? `Items scanned before error: ${data.itemsScannedBeforeError}\n`
           : '') +
         `Time: ${new Date(data.timestamp).toLocaleString()}`
       );
     }

     export function getDeletionErrorText(data: DeletionErrorData): string {
       return (
         `[Prunerr] Deletion Error\n\n` +
         `Error: ${data.error}\n` +
         (data.failedItemTitle ? `Failed item: ${data.failedItemTitle}\n` : '') +
         `Items processed before error: ${data.itemsProcessedBeforeError}\n` +
         `Time: ${new Date(data.timestamp).toLocaleString()}`
       );
     }
     ```

  4. Add Discord templates (after getScanCompleteDiscord):
     ```typescript
     export function getScanErrorDiscord(data: ScanErrorData): DiscordMessage {
       const embed: DiscordEmbed = {
         title: 'Scan Failed',
         color: COLORS.ERROR,
         description: `The library scan encountered an error during **${data.phase}**.`,
         timestamp: data.timestamp,
         footer: { text: 'Prunerr Media Library Manager' },
         fields: [
           { name: 'Error', value: data.error.substring(0, 1024), inline: false },
         ],
       };

       if (data.itemsScannedBeforeError) {
         embed.fields!.push({
           name: 'Items Before Error',
           value: String(data.itemsScannedBeforeError),
           inline: true,
         });
       }

       return { embeds: [embed], username: 'Prunerr' };
     }

     export function getDeletionErrorDiscord(data: DeletionErrorData): DiscordMessage {
       const embed: DiscordEmbed = {
         title: 'Deletion Error',
         color: COLORS.ERROR,
         description: 'An error occurred while processing the deletion queue.',
         timestamp: data.timestamp,
         footer: { text: 'Prunerr Media Library Manager' },
         fields: [
           { name: 'Error', value: data.error.substring(0, 1024), inline: false },
           { name: 'Items Processed', value: String(data.itemsProcessedBeforeError), inline: true },
         ],
       };

       if (data.failedItemTitle) {
         embed.fields!.push({
           name: 'Failed Item',
           value: data.failedItemTitle,
           inline: true,
         });
       }

       return { embeds: [embed], username: 'Prunerr' };
     }
     ```

  5. Add HTML email templates (after getScanCompleteHtml):
     ```typescript
     export function getScanErrorHtml(data: ScanErrorData): string {
       const styles = getEmailStyles();
       const content = `
         <div class="alert alert-danger">Scan failed during ${data.phase}</div>
         <table class="info-table">
           <tr><td><strong>Error:</strong></td><td>${escapeHtml(data.error)}</td></tr>
           ${data.itemsScannedBeforeError
             ? `<tr><td><strong>Items Before Error:</strong></td><td>${data.itemsScannedBeforeError}</td></tr>`
             : ''}
           <tr><td><strong>Time:</strong></td><td>${new Date(data.timestamp).toLocaleString()}</td></tr>
         </table>
       `;
       return getEmailTemplate('Scan Failed', content, styles);
     }

     export function getDeletionErrorHtml(data: DeletionErrorData): string {
       const styles = getEmailStyles();
       const content = `
         <div class="alert alert-danger">Deletion queue processing failed</div>
         <table class="info-table">
           <tr><td><strong>Error:</strong></td><td>${escapeHtml(data.error)}</td></tr>
           ${data.failedItemTitle
             ? `<tr><td><strong>Failed Item:</strong></td><td>${escapeHtml(data.failedItemTitle)}</td></tr>`
             : ''}
           <tr><td><strong>Items Processed:</strong></td><td>${data.itemsProcessedBeforeError}</td></tr>
           <tr><td><strong>Time:</strong></td><td>${new Date(data.timestamp).toLocaleString()}</td></tr>
         </table>
       `;
       return getEmailTemplate('Deletion Error', content, styles);
     }
     ```

  6. Update getPlainTextMessage switch (around line 551):
     ```typescript
     case 'SCAN_ERROR':
       return getScanErrorText(data as unknown as ScanErrorData);
     case 'DELETION_ERROR':
       return getDeletionErrorText(data as unknown as DeletionErrorData);
     ```

  7. Update getDiscordMessage switch (around line 569):
     ```typescript
     case 'SCAN_ERROR':
       return getScanErrorDiscord(data as unknown as ScanErrorData);
     case 'DELETION_ERROR':
       return getDeletionErrorDiscord(data as unknown as DeletionErrorData);
     ```

  8. Update getHtmlEmail switch (around line 587):
     ```typescript
     case 'SCAN_ERROR':
       return getScanErrorHtml(data as unknown as ScanErrorData);
     case 'DELETION_ERROR':
       return getDeletionErrorHtml(data as unknown as DeletionErrorData);
     ```

  9. Update getEmailSubject switch (around line 605):
     ```typescript
     case 'SCAN_ERROR':
       return '[Prunerr] Scan Failed';
     case 'DELETION_ERROR':
       return '[Prunerr] Deletion Error';
     ```
  </action>
  <verify>
  TypeScript compiles: `cd /home/harry/projects/library-manager && npx tsc --noEmit -p server/tsconfig.json`
  </verify>
  <done>
  SCAN_ERROR and DELETION_ERROR event types exist with Discord embeds (red color), plain text, and HTML email templates. Templates include error message, phase/context info, and timestamp.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add error notifications to scheduler tasks</name>
  <files>server/src/scheduler/tasks.ts</files>
  <action>
  Update scheduler task catch blocks to send error notifications.

  1. In scanLibraries() catch block (around line 194-224), add notification before the return:
     ```typescript
     // Send error notification
     if (dependencies.notificationService) {
       try {
         await dependencies.notificationService.notify('SCAN_ERROR', {
           error: errorMessage,
           phase: 'scanning',  // Generic - can't know exact phase from here
           itemsScannedBeforeError: 0,
           timestamp: new Date().toISOString(),
         });
       } catch (notifyError) {
         // Log but don't throw - notification failure shouldn't mask the original error
         logger.error('Failed to send scan error notification:', notifyError);
       }
     }
     ```

  2. In processDeletionQueue() catch block (around line 288-309), add notification before the return:
     ```typescript
     // Send error notification
     if (dependencies.notificationService) {
       try {
         await dependencies.notificationService.notify('DELETION_ERROR', {
           error: errorMessage,
           itemsProcessedBeforeError: 0,
           timestamp: new Date().toISOString(),
         });
       } catch (notifyError) {
         // Log but don't throw
         logger.error('Failed to send deletion error notification:', notifyError);
       }
     }
     ```

  Key principles:
  - Wrap notification calls in try/catch - notification failure should not mask original error
  - Notifications are fire-and-forget in error paths
  - Always log notification failures for debugging
  </action>
  <verify>
  TypeScript compiles: `cd /home/harry/projects/library-manager && npx tsc --noEmit -p server/tsconfig.json`
  </verify>
  <done>
  Scheduler tasks send SCAN_ERROR and DELETION_ERROR notifications when operations fail. Notification failures are logged but don't mask original errors.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add test notification endpoint</name>
  <files>server/src/routes/settings.ts</files>
  <action>
  Add POST /api/settings/test/discord endpoint to test Discord webhook configuration.

  1. Add import for NotificationService at top if not present:
     ```typescript
     import { getNotificationService } from '../notifications';
     ```

  2. Add new endpoint after the existing /test/:service endpoint (around line 677):
     ```typescript
     // POST /api/settings/test/discord - Test Discord webhook notification
     router.post('/test/discord', async (req: Request, res: Response) => {
       try {
         // Accept webhook URL from request body or fall back to stored setting
         const webhookUrl = req.body.webhookUrl || settingsRepo.getValue('notifications_discordWebhook');

         if (!webhookUrl) {
           res.status(400).json({
             success: false,
             error: 'No Discord webhook URL configured',
             details: 'Enter a webhook URL in the Notifications section and try again.',
           });
           return;
         }

         // Validate Discord webhook URL format
         if (!webhookUrl.startsWith('https://discord.com/api/webhooks/')) {
           res.status(400).json({
             success: false,
             error: 'Invalid Discord webhook URL format',
             details: 'URL must start with https://discord.com/api/webhooks/',
           });
           return;
         }

         // Send test notification using the service
         const notificationService = getNotificationService();
         const result = await notificationService.sendDiscordText(
           webhookUrl,
           '**Test notification from Prunerr!** Your Discord webhook is configured correctly.'
         );

         if (result) {
           res.json({
             success: true,
             message: 'Test notification sent successfully! Check your Discord channel.',
           });
         } else {
           res.status(400).json({
             success: false,
             error: 'Failed to send notification',
             details: 'The webhook URL may be invalid or Discord may be unreachable.',
           });
         }
       } catch (error) {
         const errorMessage = error instanceof Error ? error.message : 'Unknown error';
         logger.error('Failed to send test Discord notification:', error);
         res.status(500).json({
           success: false,
           error: `Failed to send notification: ${errorMessage}`,
         });
       }
     });
     ```

  The endpoint:
  - Accepts optional webhookUrl in request body (for testing before saving)
  - Falls back to stored setting if no URL provided
  - Validates URL format before attempting send
  - Returns clear success/failure messages
  </action>
  <verify>
  TypeScript compiles: `cd /home/harry/projects/library-manager && npx tsc --noEmit -p server/tsconfig.json`
  </verify>
  <done>
  POST /api/settings/test/discord endpoint exists. Validates webhook URL format, sends test message, returns success/failure with helpful details.
  </done>
</task>

<task type="auto">
  <name>Task 5: Add test notification button to Settings UI</name>
  <files>client/src/components/Settings/Settings.tsx</files>
  <action>
  Add a "Test Notification" button to the Discord webhook section in Settings.

  1. Add state for test result at top of Settings component (around line 107):
     ```typescript
     const [discordTestResult, setDiscordTestResult] = useState<{
       status: 'idle' | 'loading' | 'success' | 'error';
       message?: string
     }>({ status: 'idle' });
     ```

  2. Add test handler function (around line 186, after handleNotificationChange):
     ```typescript
     const handleTestDiscord = async () => {
       const webhookUrl = currentSettings.notifications?.discordWebhook;
       if (!webhookUrl) {
         setDiscordTestResult({ status: 'error', message: 'Enter a webhook URL first' });
         return;
       }

       setDiscordTestResult({ status: 'loading' });

       try {
         const response = await fetch('/api/settings/test/discord', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({ webhookUrl }),
         });

         const data = await response.json();

         if (data.success) {
           setDiscordTestResult({ status: 'success', message: data.message });
         } else {
           setDiscordTestResult({ status: 'error', message: data.error || 'Test failed' });
         }
       } catch (error) {
         setDiscordTestResult({
           status: 'error',
           message: error instanceof Error ? error.message : 'Failed to send test'
         });
       }

       // Clear result after 5 seconds
       setTimeout(() => setDiscordTestResult({ status: 'idle' }), 5000);
     };
     ```

  3. Update the Discord webhook section (around line 411-421) to include test button and result:
     ```tsx
     {currentSettings.notifications?.discordEnabled && (
       <div className="pl-4 border-l-2 border-violet-500/30 space-y-4">
         <Input
           label="Webhook URL"
           type="url"
           value={currentSettings.notifications?.discordWebhook || ''}
           onChange={(e) => handleNotificationChange('discordWebhook', e.target.value)}
           placeholder="https://discord.com/api/webhooks/..."
         />

         <div className="flex items-center gap-4">
           <Button
             variant="secondary"
             size="sm"
             onClick={handleTestDiscord}
             disabled={!currentSettings.notifications?.discordWebhook || discordTestResult.status === 'loading'}
           >
             {discordTestResult.status === 'loading' ? (
               <>
                 <Loader2 className="w-4 h-4 animate-spin" />
                 Sending...
               </>
             ) : (
               <>
                 <Bell className="w-4 h-4" />
                 Test Notification
               </>
             )}
           </Button>

           {discordTestResult.status === 'success' && (
             <div className="flex items-center gap-2 text-emerald-400">
               <CheckCircle className="w-4 h-4" />
               <span className="text-sm">{discordTestResult.message}</span>
             </div>
           )}

           {discordTestResult.status === 'error' && (
             <div className="flex items-center gap-2 text-ruby-400">
               <XCircle className="w-4 h-4" />
               <span className="text-sm">{discordTestResult.message}</span>
             </div>
           )}
         </div>
       </div>
     )}
     ```

  The CheckCircle, XCircle, and Loader2 icons are already imported. Bell is already imported.
  </action>
  <verify>
  TypeScript compiles: `cd /home/harry/projects/library-manager && npx tsc --noEmit -p client/tsconfig.json`
  </verify>
  <done>
  Settings UI shows "Test Notification" button when Discord webhook is enabled. Button sends test notification and shows success/error feedback inline. Result clears after 5 seconds.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript compilation:**
   ```bash
   cd /home/harry/projects/library-manager
   npx tsc --noEmit -p server/tsconfig.json
   npx tsc --noEmit -p client/tsconfig.json
   ```

2. **Manual verification (brief):**
   - Start dev server: `npm run dev` in both client and server directories
   - Navigate to Settings > Notifications
   - Enable Discord, enter webhook URL
   - Click "Test Notification" - verify test message appears in Discord
   - Verify success feedback in UI

3. **Notification types registered:**
   - Grep for all event types: `grep -n "SCAN_ERROR\|DELETION_ERROR" server/src/`
   - Should find: templates.ts (type + templates), tasks.ts (usage)
</verification>

<success_criteria>
- Discord webhook URL is read from database settings (not hardcoded or env-only)
- Test notification endpoint exists at POST /api/settings/test/discord
- Test button in Settings UI sends test notification and shows result
- SCAN_ERROR notifications sent when scans fail
- DELETION_ERROR notifications sent when deletions fail
- Error templates show red color in Discord embeds
- Notification failures logged but don't break main operations
</success_criteria>

<output>
After completion, create `.planning/phases/05-notifications/05-01-SUMMARY.md` following the template at `@~/.claude/get-shit-done/templates/summary.md`
</output>
