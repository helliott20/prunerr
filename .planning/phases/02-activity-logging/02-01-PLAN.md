---
phase: 02-activity-logging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/db/schema.ts
  - server/src/db/repositories/activity.ts
  - server/src/routes/activity.ts
  - server/src/services/deletion.ts
  - server/src/services/scanner.ts
autonomous: true

must_haves:
  truths:
    - "Activity log table stores all system events with timestamps"
    - "Each activity has actor attribution (scheduler, user, or rule)"
    - "Activity API returns paginated results in reverse chronological order"
    - "Deletions automatically create activity log entries"
    - "Scans automatically create activity log entries"
  artifacts:
    - path: "server/src/db/schema.ts"
      provides: "activity_log table migration"
      contains: "CREATE TABLE IF NOT EXISTS activity_log"
    - path: "server/src/db/repositories/activity.ts"
      provides: "Activity repository with pagination and filtering"
      exports: ["getActivityLog", "logActivity"]
    - path: "server/src/routes/activity.ts"
      provides: "Enhanced activity routes using activity_log table"
      contains: "router.get('/'"
  key_links:
    - from: "server/src/services/deletion.ts"
      to: "server/src/db/repositories/activity.ts"
      via: "logActivity call in executeDelete"
      pattern: "logActivity\\("
    - from: "server/src/services/scanner.ts"
      to: "server/src/db/repositories/activity.ts"
      via: "logActivity call in scan methods"
      pattern: "logActivity\\("
---

<objective>
Create the backend infrastructure for unified activity logging with actor attribution.

Purpose: Provide a single source of truth for all system events that can be queried efficiently, replacing the current approach of reconstructing activity from multiple tables.

Output: activity_log table, repository with pagination/filtering, enhanced API routes, and integration with deletion and scanner services.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-activity-logging/02-RESEARCH.md

Key patterns from research:
- Follow history.ts repository pattern for pagination
- Actor types: 'scheduler' | 'user' | 'rule'
- Event types: 'scan' | 'deletion' | 'rule_match' | 'protection' | 'manual_action' | 'error'
- Denormalize target_title and actor_name for efficient queries
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create activity_log table and repository</name>
  <files>
    server/src/db/schema.ts
    server/src/db/repositories/activity.ts
  </files>
  <action>
Add migration version 5 to schema.ts creating the activity_log table:

```sql
CREATE TABLE IF NOT EXISTS activity_log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  event_type TEXT NOT NULL CHECK (event_type IN ('scan', 'deletion', 'rule_match', 'protection', 'manual_action', 'error')),
  action TEXT NOT NULL,
  actor_type TEXT NOT NULL CHECK (actor_type IN ('scheduler', 'user', 'rule')),
  actor_id TEXT,
  actor_name TEXT,
  target_type TEXT,
  target_id INTEGER,
  target_title TEXT,
  metadata TEXT,
  created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_activity_log_created_at ON activity_log(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_activity_log_event_type ON activity_log(event_type);
CREATE INDEX IF NOT EXISTS idx_activity_log_actor_type ON activity_log(actor_type);
```

Create server/src/db/repositories/activity.ts following the history.ts pattern:

1. Define interfaces:
   - ActivityLogEntry (id, eventType, action, actorType, actorId, actorName, targetType, targetId, targetTitle, metadata, createdAt)
   - ActivityQueryParams (eventTypes?, actorTypes?, search?, page?, limit?, dateRange?)
   - ActivityQueryResult (items, total, page, limit)

2. Implement logActivity(entry: Omit<ActivityLogEntry, 'id' | 'createdAt'>) function that inserts into activity_log

3. Implement getActivityLog(params: ActivityQueryParams): ActivityQueryResult function with:
   - Pagination (page, limit with max 100)
   - Date range filtering (24h, 7d, 30d, all) using the same pattern as history.ts
   - Optional event type filtering (IN clause)
   - Optional actor type filtering (IN clause)
   - Optional search on target_title (LIKE)
   - Results ordered by created_at DESC

4. Export: { logActivity, getActivityLog }
  </action>
  <verify>
TypeScript compiles without errors: `cd /home/harry/projects/library-manager && npm run build --workspace=server`
  </verify>
  <done>
activity_log table migration exists in schema.ts, activity.ts repository exports logActivity and getActivityLog functions with proper typing and pagination
  </done>
</task>

<task type="auto">
  <name>Task 2: Update activity routes to use new repository</name>
  <files>
    server/src/routes/activity.ts
  </files>
  <action>
Refactor server/src/routes/activity.ts to use the new activity repository:

1. Import getActivityLog from the new repository

2. Keep the existing GET /recent endpoint but update its implementation:
   - Call getActivityLog with limit from query params
   - Transform results to match existing ActivityItem interface for backward compatibility
   - This maintains compatibility with Dashboard's useRecentActivity hook

3. Add new GET / endpoint for the full activity log with filtering:
   - Accept query params: page, limit, dateRange, eventTypes (comma-separated), actorTypes (comma-separated), search
   - Call getActivityLog with parsed params
   - Return { success: true, data: { items, total, page, limit } }

4. Response format for items should include:
   - id, eventType, action, actorType, actorName, targetType, targetId, targetTitle, metadata, createdAt

Note: The /recent endpoint will initially return empty until services start logging to the new table. This is expected - Phase 2 Plan 1 sets up infrastructure, activity will be logged going forward.
  </action>
  <verify>
Server starts without errors and endpoints respond:
```bash
cd /home/harry/projects/library-manager && npm run build --workspace=server
```
  </verify>
  <done>
Activity routes use the new repository, GET / returns paginated activity log, GET /recent remains backward compatible
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate activity logging into deletion and scanner services</name>
  <files>
    server/src/services/deletion.ts
    server/src/services/scanner.ts
  </files>
  <action>
Update deletion.ts:

1. Import logActivity from '../db/repositories/activity'

2. In executeDelete method, after recording in deletion_history, also log to activity_log:
   ```typescript
   logActivity({
     eventType: 'deletion',
     action: action === DeletionAction.UNMONITOR_ONLY ? 'unmonitored' : 'deleted',
     actorType: options.ruleId ? 'rule' : 'user',
     actorId: options.ruleId?.toString() || null,
     actorName: ruleName || 'Manual deletion',
     targetType: 'media_item',
     targetId: item.id,
     targetTitle: item.title,
     metadata: JSON.stringify({
       mediaType: item.type,
       fileSize: item.file_size,
       deletionAction: action,
       overseerrReset: overseerrReset
     })
   });
   ```

3. In markForDeletion method, log when items are queued:
   ```typescript
   logActivity({
     eventType: 'rule_match',
     action: 'item_queued',
     actorType: ruleId ? 'rule' : 'user',
     actorId: ruleId?.toString() || null,
     actorName: ruleName || 'Manual queue',
     targetType: 'media_item',
     targetId: itemId,
     targetTitle: item.title,
     metadata: JSON.stringify({
       gracePeriodDays,
       deleteAfter: deleteAfter.toISOString()
     })
   });
   ```

Update scanner.ts:

1. Import logActivity from '../db/repositories/activity'

2. At scan start, log:
   ```typescript
   logActivity({
     eventType: 'scan',
     action: 'started',
     actorType: 'scheduler',
     actorId: 'system',
     actorName: 'Library Scan',
     targetType: null,
     targetId: null,
     targetTitle: null,
     metadata: null
   });
   ```

3. At scan completion, log:
   ```typescript
   logActivity({
     eventType: 'scan',
     action: scan.status === 'completed' ? 'completed' : 'failed',
     actorType: 'scheduler',
     actorId: 'system',
     actorName: 'Library Scan',
     targetType: 'scan',
     targetId: scan.id,
     targetTitle: null,
     metadata: JSON.stringify({
       itemsScanned: scan.items_scanned,
       itemsFlagged: scan.items_flagged,
       duration: endTime - startTime
     })
   });
   ```

Note: Find the appropriate methods/locations in scanner.ts where scans start and complete. The research indicates scan_history is already written to - add activity logging alongside it.
  </action>
  <verify>
Build succeeds and services compile:
```bash
cd /home/harry/projects/library-manager && npm run build --workspace=server
```

Manually verify by checking that the new activity logging calls exist in the built output.
  </verify>
  <done>
Deletion service logs deletions and queue additions to activity_log, scanner service logs scan start/completion to activity_log
  </done>
</task>

</tasks>

<verification>
1. TypeScript builds without errors for server workspace
2. Migration 5 exists in schema.ts with activity_log table
3. activity.ts repository exists with logActivity and getActivityLog exports
4. activity.ts routes has both / and /recent endpoints
5. deletion.ts contains logActivity calls
6. scanner.ts contains logActivity calls
</verification>

<success_criteria>
- activity_log table schema defined in migration
- Repository provides logActivity and getActivityLog with pagination
- API endpoints return activity data (empty until actions occur)
- Deletion and scanner services log to activity_log
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-activity-logging/02-01-SUMMARY.md`
</output>
