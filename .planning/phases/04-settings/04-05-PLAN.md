---
phase: 04-settings
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/routes/settings.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Schedule changes take effect immediately without restart"
    - "Import validates setting keys and warns about unknown keys"
    - "Scheduler recalculates next run time when schedule settings change"
  artifacts:
    - path: "server/src/routes/settings.ts"
      provides: "Scheduler update call when schedule changes"
      contains: "scheduler.updateSchedule"
    - path: "server/src/routes/settings.ts"
      provides: "Setting key validation in import"
      contains: "KNOWN_SETTING_PREFIXES"
  key_links:
    - from: "PUT /api/settings"
      to: "scheduler"
      via: "updateSchedule call when schedule settings saved"
      pattern: "getScheduler.*updateSchedule"
    - from: "POST /api/settings/import"
      to: "validation"
      via: "Check setting keys against known prefixes"
      pattern: "KNOWN_SETTING_PREFIXES"
---

<objective>
Fix scheduler notification on schedule changes and improve import validation.

Purpose: Two secondary gaps from verification: (1) When schedule settings change, the scheduler isn't notified, so the "next run" display doesn't update until after the next execution. (2) Import only validates JSON structure, not whether setting keys are valid, which could lead to silently corrupted settings.

Output: Scheduler updates immediately when schedule changes, import warns about unknown setting keys.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-settings/04-VERIFICATION.md
@server/src/routes/settings.ts
@server/src/scheduler/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Notify scheduler when schedule settings change</name>
  <files>server/src/routes/settings.ts</files>
  <action>
In `server/src/routes/settings.ts`:

1. Add import for scheduler at the top of the file (with other imports):
```typescript
import { getScheduler } from '../scheduler';
```

2. In the PUT '/' handler, after saving schedule settings and before the logger.info call (around line 256-258), add scheduler update logic:

```typescript
// Update scheduler if schedule settings were changed
const hasScheduleSettings = savedSettings.some(s => s.key.startsWith('schedule_'));
if (hasScheduleSettings) {
  try {
    const scheduler = getScheduler();

    // Build cron expression from saved schedule settings
    const interval = settings.schedule?.interval || 'daily';
    const time = settings.schedule?.time || '03:00';
    const dayOfWeek = settings.schedule?.dayOfWeek;

    // Parse time (format: "HH:mm")
    const [hour, minute] = time.split(':').map(Number);

    let cronExpression: string;
    switch (interval) {
      case 'hourly':
        cronExpression = `${minute} * * * *`;
        break;
      case 'weekly':
        // dayOfWeek: 0 = Sunday, 1 = Monday, etc.
        cronExpression = `${minute} ${hour} * * ${dayOfWeek ?? 0}`;
        break;
      case 'daily':
      default:
        cronExpression = `${minute} ${hour} * * *`;
        break;
    }

    scheduler.updateSchedule('scanLibraries', cronExpression);
    logger.info(`Scheduler updated with new cron: ${cronExpression}`);
  } catch (error) {
    logger.error('Failed to update scheduler:', error);
    // Don't fail the request - settings are saved, scheduler will pick up on next cycle
  }
}
```

Note: The scheduler.updateSchedule() method already exists and handles validation, job rescheduling, and next run time calculation.
  </action>
  <verify>
    - TypeScript compiles: `cd /home/harry/projects/library-manager/server && npx tsc --noEmit`
    - Import exists: `grep -n "getScheduler" server/src/routes/settings.ts`
    - Scheduler update call exists: `grep -n "updateSchedule" server/src/routes/settings.ts`
  </verify>
  <done>
    - Scheduler is notified when schedule settings change
    - Cron expression is correctly built from interval/time/dayOfWeek
    - Error handling prevents request failure if scheduler update fails
  </done>
</task>

<task type="auto">
  <name>Task 2: Add setting key validation to import endpoint</name>
  <files>server/src/routes/settings.ts</files>
  <action>
In `server/src/routes/settings.ts`:

1. Add known setting prefixes constant near the top (after the ImportSettingsSchema definition):
```typescript
// Known setting key prefixes for validation
const KNOWN_SETTING_PREFIXES = [
  'plex_',
  'tautulli_',
  'sonarr_',
  'radarr_',
  'overseerr_',
  'unraid_',
  'notifications_',
  'schedule_',
  'display_',
];

function isKnownSettingKey(key: string): boolean {
  return KNOWN_SETTING_PREFIXES.some(prefix => key.startsWith(prefix));
}
```

2. In the POST '/import' handler, after parsing succeeds but before saving (around line 139), add validation:

```typescript
const { settings } = parsed.data;

// Validate setting keys
const unknownKeys = Object.keys(settings).filter(key => !isKnownSettingKey(key));
if (unknownKeys.length > 0) {
  logger.warn(`Import contains unknown setting keys: ${unknownKeys.join(', ')}`);
}

// Check for expected settings structure (warn if missing common keys)
const hasServiceSettings = Object.keys(settings).some(k =>
  k.startsWith('plex_') || k.startsWith('tautulli_') || k.startsWith('sonarr_') || k.startsWith('radarr_')
);
if (!hasServiceSettings) {
  logger.warn('Imported settings file contains no service configuration');
}

// Convert to array format for setMultiple
const settingsArray = Object.entries(settings)
  .filter(([key]) => isKnownSettingKey(key))  // Only import known keys
  .map(([key, value]) => ({ key, value }));

if (settingsArray.length === 0) {
  res.status(400).json({
    success: false,
    error: 'No valid settings found in import file',
    details: unknownKeys.length > 0
      ? `Unknown keys ignored: ${unknownKeys.slice(0, 5).join(', ')}${unknownKeys.length > 5 ? '...' : ''}`
      : 'File appears to be empty or incorrectly formatted',
  });
  return;
}
```

3. Update the response to include information about filtered keys:
```typescript
res.json({
  success: true,
  message: `Successfully imported ${imported.length} settings`,
  data: {
    count: imported.length,
    skipped: unknownKeys.length,
    skippedKeys: unknownKeys.length > 0 ? unknownKeys.slice(0, 5) : undefined,
  },
});
```
  </action>
  <verify>
    - TypeScript compiles: `cd /home/harry/projects/library-manager/server && npx tsc --noEmit`
    - Known prefixes defined: `grep -n "KNOWN_SETTING_PREFIXES" server/src/routes/settings.ts`
    - Validation function exists: `grep -n "isKnownSettingKey" server/src/routes/settings.ts`
  </verify>
  <done>
    - Import validates setting keys against known prefixes
    - Unknown keys are logged as warnings and skipped
    - Response includes count of skipped keys
    - Empty/invalid imports return 400 error
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Server compiles: `cd /home/harry/projects/library-manager/server && npx tsc --noEmit`
2. Test scheduler update:
   - Navigate to Settings, change scan interval from "Daily" to "Hourly"
   - Save settings
   - Check server logs for "Scheduler updated with new cron" message
   - Navigate to Dashboard, verify "Next scan" time updated
3. Test import validation:
   - Create a JSON file with unknown keys (e.g., `{"unknown_key": "value"}`)
   - Try to import - should get error or warning about unknown keys
   - Create valid export file, import should succeed with count
</verification>

<success_criteria>
- Scheduler updates immediately when schedule settings change (no restart required)
- "Next scan" display updates after saving schedule changes
- Import rejects files with no valid settings
- Import logs warnings about unknown keys
- Response includes skipped key count
</success_criteria>

<output>
After completion, create `.planning/phases/04-settings/04-05-SUMMARY.md`
</output>
