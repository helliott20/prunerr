---
phase: 04-settings
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/contexts/DisplayPreferencesContext.tsx
  - client/src/types/index.ts
  - client/src/lib/utils.ts
  - client/src/main.tsx
  - client/src/components/Settings/Settings.tsx
autonomous: true

must_haves:
  truths:
    - "User can select date format preference (relative, absolute, ISO)"
    - "User can select time format preference (12h, 24h)"
    - "User can select file size unit preference (auto, MB, GB, TB)"
    - "Display preferences persist across page refreshes"
  artifacts:
    - path: "client/src/contexts/DisplayPreferencesContext.tsx"
      provides: "Global display preferences context and provider"
      exports: ["DisplayPreferencesProvider", "useDisplayPreferences"]
    - path: "client/src/types/index.ts"
      provides: "DisplaySettings type definition"
      contains: "interface DisplaySettings"
  key_links:
    - from: "client/src/main.tsx"
      to: "DisplayPreferencesProvider"
      via: "Context provider wrapping App"
      pattern: "DisplayPreferencesProvider"
    - from: "client/src/contexts/DisplayPreferencesContext.tsx"
      to: "/api/settings"
      via: "Persist preferences to backend"
      pattern: "useSaveSettings"
---

<objective>
Add display preferences infrastructure allowing users to configure date format, time format, and file size units.

Purpose: Users have different preferences for viewing dates (relative "2 hours ago" vs absolute "Jan 24, 2026") and file sizes (auto-scaling vs fixed units). This phase adds the infrastructure for configurable display formats.

Output: DisplayPreferencesContext providing global format preferences, UI section in Settings for configuration, utility functions updated to consume preferences.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-settings/04-RESEARCH.md
@client/src/types/index.ts
@client/src/lib/utils.ts
@client/src/components/Settings/Settings.tsx
@client/src/main.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DisplaySettings type and create DisplayPreferencesContext</name>
  <files>
    client/src/types/index.ts
    client/src/contexts/DisplayPreferencesContext.tsx
  </files>
  <action>
1. In `client/src/types/index.ts`, add DisplaySettings interface after ScheduleSettings:
```typescript
export interface DisplaySettings {
  dateFormat: 'relative' | 'absolute' | 'iso';
  timeFormat: '12h' | '24h';
  fileSizeUnit: 'auto' | 'MB' | 'GB' | 'TB';
}
```

2. Update Settings interface to include display:
```typescript
export interface Settings {
  services: { ... };
  notifications?: NotificationSettings;
  schedule?: ScheduleSettings;
  display?: DisplaySettings;  // Add this
}
```

3. Create `client/src/contexts/DisplayPreferencesContext.tsx`:
   - Create DisplayPreferencesContext with `preferences` and `setPreferences`
   - Create DisplayPreferencesProvider that:
     - Uses useSettings() and useSaveSettings() from useApi
     - Initializes with sensible defaults: dateFormat='relative', timeFormat='24h', fileSizeUnit='auto'
     - Syncs preferences from API on load
     - Persists changes to backend via saveMutation with display key
   - Export useDisplayPreferences() hook that throws if used outside provider
   - Handle loading state gracefully (use defaults until settings load)
  </action>
  <verify>
    - TypeScript compiles: `cd /home/harry/projects/library-manager/client && npx tsc --noEmit`
    - Context file exports DisplayPreferencesProvider and useDisplayPreferences
  </verify>
  <done>
    - DisplaySettings type exists in types/index.ts
    - Settings interface includes optional display field
    - DisplayPreferencesContext.tsx exists with provider and hook
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire DisplayPreferencesProvider into app and add Settings UI section</name>
  <files>
    client/src/main.tsx
    client/src/components/Settings/Settings.tsx
  </files>
  <action>
1. In `client/src/main.tsx`:
   - Import DisplayPreferencesProvider from '@/contexts/DisplayPreferencesContext'
   - Wrap the App component (inside QueryClientProvider but can be anywhere inside):
     ```tsx
     <QueryClientProvider client={queryClient}>
       <DisplayPreferencesProvider>
         <App />
       </DisplayPreferencesProvider>
     </QueryClientProvider>
     ```

2. In `client/src/components/Settings/Settings.tsx`:
   - Import useDisplayPreferences from '@/contexts/DisplayPreferencesContext'
   - Import Monitor icon from lucide-react (for Display section header)
   - Add a new Display Preferences Card after the Scan Schedule Card:
     - Header with Monitor icon, title "Display Preferences", description "Customize how dates, times, and sizes are shown"
     - Three Select dropdowns in a grid:
       a. Date Format: options "Relative (2 hours ago)", "Absolute (Jan 24, 2026)", "ISO (2026-01-24)"
       b. Time Format: options "12-hour (3:00 PM)", "24-hour (15:00)"
       c. File Size Unit: options "Auto (best fit)", "Always MB", "Always GB", "Always TB"
     - Use the existing select styling from the schedule section
     - Call setPreferences() on change for each dropdown
   - Use useDisplayPreferences() to get current values for the selects
  </action>
  <verify>
    - App builds: `cd /home/harry/projects/library-manager/client && npm run build`
    - Settings page shows Display Preferences section with three dropdowns
  </verify>
  <done>
    - main.tsx wraps App with DisplayPreferencesProvider
    - Settings page has Display Preferences section with Date Format, Time Format, and File Size Unit dropdowns
    - Selecting a preference triggers save to backend
  </done>
</task>

<task type="auto">
  <name>Task 3: Update utility functions to support configurable formats</name>
  <files>
    client/src/lib/utils.ts
  </files>
  <action>
1. In `client/src/lib/utils.ts`, add new preference-aware format functions:

```typescript
/**
 * Format date based on user preference
 */
export function formatDateWithPreference(
  date: string | Date,
  preference: 'relative' | 'absolute' | 'iso'
): string {
  const dateObj = typeof date === 'string' ? parseISO(date) : date;

  switch (preference) {
    case 'relative':
      return formatDistanceToNow(dateObj, { addSuffix: true });
    case 'absolute':
      return format(dateObj, 'MMM d, yyyy');
    case 'iso':
      return format(dateObj, 'yyyy-MM-dd');
    default:
      return formatDistanceToNow(dateObj, { addSuffix: true });
  }
}

/**
 * Format time based on user preference
 */
export function formatTimeWithPreference(
  date: string | Date,
  preference: '12h' | '24h'
): string {
  const dateObj = typeof date === 'string' ? parseISO(date) : date;
  return format(dateObj, preference === '12h' ? 'h:mm a' : 'HH:mm');
}

/**
 * Format date and time together based on preferences
 */
export function formatDateTimeWithPreference(
  date: string | Date,
  datePreference: 'relative' | 'absolute' | 'iso',
  timePreference: '12h' | '24h'
): string {
  const dateObj = typeof date === 'string' ? parseISO(date) : date;

  if (datePreference === 'relative') {
    return formatDistanceToNow(dateObj, { addSuffix: true });
  }

  const dateStr = datePreference === 'iso'
    ? format(dateObj, 'yyyy-MM-dd')
    : format(dateObj, 'MMM d, yyyy');
  const timeStr = format(dateObj, timePreference === '12h' ? 'h:mm a' : 'HH:mm');

  return `${dateStr} ${timeStr}`;
}

/**
 * Format bytes with user preference for unit
 */
export function formatBytesWithPreference(
  bytes: number,
  preference: 'auto' | 'MB' | 'GB' | 'TB',
  decimals = 2
): string {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;

  if (preference === 'auto') {
    // Use existing auto logic
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
  }

  // Fixed unit
  const unitPowers: Record<string, number> = { MB: 2, GB: 3, TB: 4 };
  const power = unitPowers[preference] || 3;
  const value = bytes / Math.pow(k, power);
  return `${parseFloat(value.toFixed(dm))} ${preference}`;
}
```

Keep the original formatBytes, formatDate, formatRelativeTime functions unchanged for backward compatibility.
  </action>
  <verify>
    - TypeScript compiles: `cd /home/harry/projects/library-manager/client && npx tsc --noEmit`
    - New functions exported from utils.ts
  </verify>
  <done>
    - formatDateWithPreference, formatTimeWithPreference, formatDateTimeWithPreference, formatBytesWithPreference functions exist in utils.ts
    - Original format functions unchanged for backward compatibility
    - All functions handle edge cases (0 bytes, invalid dates)
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. App builds without errors: `cd /home/harry/projects/library-manager/client && npm run build`
2. Start dev server and navigate to Settings page
3. Display Preferences section visible with three dropdowns
4. Changing each dropdown triggers a save (check Network tab for PUT /api/settings)
5. Refresh page - preferences persist (values remain selected)
</verification>

<success_criteria>
- DisplayPreferencesContext exists and is wired into app
- Settings page shows Display Preferences section with Date Format, Time Format, File Size Unit dropdowns
- Preferences persist to backend and reload on page refresh
- New preference-aware utility functions available for components to use
</success_criteria>

<output>
After completion, create `.planning/phases/04-settings/04-01-SUMMARY.md`
</output>
