---
phase: 01-ui-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/components/common/EmptyState.tsx
  - client/src/components/Dashboard/Dashboard.tsx
  - client/src/components/Library/Library.tsx
  - client/src/components/Queue/Queue.tsx
  - client/src/components/History/History.tsx
  - client/src/components/Rules/Rules.tsx
  - client/src/components/Recommendations/Recommendations.tsx
autonomous: true

must_haves:
  truths:
    - "User sees helpful empty states with clear explanations when no data exists"
    - "User sees actionable guidance in empty states (what to do next)"
    - "User sees contextual empty states that differ between 'no data yet' and 'no results match filters'"
  artifacts:
    - path: "client/src/components/common/EmptyState.tsx"
      provides: "Reusable empty state component with action support"
      exports: ["EmptyState"]
  key_links:
    - from: "client/src/components/Library/Library.tsx"
      to: "client/src/components/common/EmptyState.tsx"
      via: "import and use for empty library"
      pattern: "EmptyState"
    - from: "client/src/components/Dashboard/Dashboard.tsx"
      to: "client/src/components/common/EmptyState.tsx"
      via: "import and use for empty sections"
      pattern: "EmptyState"
---

<objective>
Standardize and improve empty state components across all views.

Purpose: Current empty states exist but have inconsistent messaging and lack actionable guidance. Users should understand WHY something is empty and WHAT they can do about it.

Output: Consistent, helpful empty states throughout the application that guide users toward the next logical action.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-ui-polish/01-RESEARCH.md

# Existing empty state patterns
@client/src/components/Dashboard/Dashboard.tsx
@client/src/components/Library/Library.tsx
@client/src/components/Queue/Queue.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create standardized EmptyState component</name>
  <files>client/src/components/common/EmptyState.tsx</files>
  <action>
Create a reusable EmptyState component that supports three variants:

```typescript
interface EmptyStateProps {
  icon: React.ElementType;
  title: string;
  description: string;
  variant?: 'default' | 'success' | 'filtered';
  action?: {
    label: string;
    onClick: () => void;
  };
  secondaryAction?: {
    label: string;
    onClick: () => void;
  };
}
```

Implementation requirements:
- Default variant: neutral styling (surface colors) - for "no data yet" states
- Success variant: emerald/green styling - for "all done/cleared" states
- Filtered variant: amber/warning styling - for "no results match filters" states
- Optional primary action button (uses Button component)
- Optional secondary action as a text link

Styling (match existing patterns from Dashboard.tsx EmptyState):
```tsx
<div className="empty-state py-12">
  <div className={cn(
    'w-16 h-16 mx-auto mb-4 rounded-2xl flex items-center justify-center',
    variant === 'success' ? 'bg-emerald-500/10' :
    variant === 'filtered' ? 'bg-amber-500/10' :
    'bg-surface-800/50'
  )}>
    <Icon className={cn(
      'w-8 h-8',
      variant === 'success' ? 'text-emerald-400' :
      variant === 'filtered' ? 'text-amber-400' :
      'text-surface-500'
    )} />
  </div>
  <h3 className="text-lg font-display font-semibold text-surface-200">{title}</h3>
  <p className="text-sm text-surface-500 mt-1 max-w-md mx-auto">{description}</p>
  {action && (
    <Button variant="primary" onClick={action.onClick} className="mt-4">
      {action.label}
    </Button>
  )}
  {secondaryAction && (
    <button
      onClick={secondaryAction.onClick}
      className="mt-2 text-sm text-accent-400 hover:text-accent-300"
    >
      {secondaryAction.label}
    </button>
  )}
</div>
```

Export the component from `client/src/components/common/EmptyState.tsx`.
  </action>
  <verify>
- File exists: `client/src/components/common/EmptyState.tsx`
- Component exports EmptyState
- Supports all three variants
- Supports optional action buttons
- TypeScript compiles: `cd /home/harry/projects/library-manager/client && npx tsc --noEmit`
  </verify>
  <done>Reusable EmptyState component created with variant support and action buttons</done>
</task>

<task type="auto">
  <name>Task 2: Update Dashboard and Library empty states</name>
  <files>client/src/components/Dashboard/Dashboard.tsx, client/src/components/Library/Library.tsx</files>
  <action>
**Dashboard.tsx:**
1. Replace the inline EmptyState function with import from `@/components/common/EmptyState`
2. Update each empty state usage with improved messaging:

Recent Activity empty state:
- icon: Clock
- title: "No recent activity"
- description: "Activity will appear here as you scan your library and manage media. Run a library sync to get started."
- action: { label: "Sync Library", onClick: handleSync } (pass down or wire up sync)

Upcoming Deletions empty state:
- icon: CheckCircle
- variant: "success"
- title: "Queue is clear"
- description: "No items are scheduled for deletion. Media flagged by rules or manually queued will appear here."

Recommendations empty state:
- icon: CheckCircle
- variant: "success"
- title: "Library is in great shape!"
- description: "No stale content found based on your watch history. Items unwatched for 90+ days will appear here."

**Library.tsx:**
1. Import EmptyState from `@/components/common/EmptyState`
2. Replace EmptyLibrary component with EmptyState usage:

When search is active (no results):
- icon: Search (from lucide-react)
- variant: "filtered"
- title: "No results found"
- description: `No media matching "${search}" was found. Try a different search term or clear filters.`
- action: { label: "Clear Search", onClick: () => setSearchInput('') }

When library is empty (no search):
- icon: LibraryIcon
- title: "Your library is empty"
- description: "Sync your library to import media from Plex and start managing your collection."
- action: { label: "Sync Library", onClick: handleSync }

When filters are applied but no results:
- icon: SlidersHorizontal
- variant: "filtered"
- title: "No items match filters"
- description: "Try adjusting your type or status filters to see more items."
- action: { label: "Clear Filters", onClick: () => { setMediaType('all'); setStatus('all'); } }
  </action>
  <verify>
- Dashboard.tsx imports EmptyState from common
- Library.tsx imports EmptyState from common
- Empty states have actionable messaging
- Empty states have appropriate actions where useful
- TypeScript compiles without errors
  </verify>
  <done>Dashboard and Library have improved empty states with contextual messaging and actions</done>
</task>

<task type="auto">
  <name>Task 3: Update remaining views' empty states</name>
  <files>client/src/components/Queue/Queue.tsx, client/src/components/History/History.tsx, client/src/components/Rules/Rules.tsx, client/src/components/Recommendations/Recommendations.tsx</files>
  <action>
Update empty states in remaining views:

**Queue.tsx:**
1. Import EmptyState from `@/components/common/EmptyState`
2. Replace inline empty state:
- icon: CheckCircle
- variant: "success"
- title: "Queue is empty"
- description: "No items are currently marked for deletion. Browse your library to queue items for cleanup, or set up rules to automate the process."
- action: { label: "Browse Library", onClick: () => navigate('/library') } (use react-router navigate)
- secondaryAction: { label: "Set up rules", onClick: () => navigate('/rules') }

**History.tsx:**
1. Import EmptyState from `@/components/common/EmptyState`
2. Update empty state:
- icon: HistoryIcon (already imported)
- title: "No deletion history"
- description: "Items you delete will appear here for your records. Process your deletion queue to start tracking cleanup activity."

When search/filters return no results:
- icon: Search
- variant: "filtered"
- title: "No matching history"
- description: "No deleted items match your search. Try different search terms or adjust the date range."
- action: { label: "Clear Search", onClick: () => { setSearch(''); setDateRange('all'); } }

**Rules.tsx:**
1. Check current empty state and update to use common EmptyState
2. Empty state messaging:
- icon: Zap (or similar)
- title: "No rules configured"
- description: "Create rules to automatically flag media for deletion based on watch status, age, size, and more."
- action: { label: "Create Your First Rule", onClick: openCreateRuleModal } (or navigate to rule creation)

**Recommendations.tsx:**
1. Check if this view has its own empty state or uses Dashboard's
2. Update if needed:
- icon: CheckCircle
- variant: "success"
- title: "No recommendations"
- description: "Your library is well-maintained! Items that haven't been watched in a while will appear here as suggestions."
  </action>
  <verify>
- All listed files import EmptyState from common
- Empty states have contextual, helpful messages
- Empty states include actions where appropriate
- Filtered/search states use 'filtered' variant
- Success states use 'success' variant
- TypeScript compiles: `cd /home/harry/projects/library-manager/client && npx tsc --noEmit`
- Build succeeds: `cd /home/harry/projects/library-manager/client && npm run build`
  </verify>
  <done>All views have consistent, helpful empty states with appropriate variants and actions</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compilation passes with no errors
2. Production build completes successfully
3. EmptyState component exists in common directory
4. All views use the common EmptyState component
5. Empty states distinguish between "no data" and "no filter results"
6. Empty states include actionable guidance where appropriate
</verification>

<success_criteria>
- User sees helpful empty states with guidance when no items match filters or on first use
- Empty states clearly explain WHY the view is empty
- Empty states offer actionable next steps (buttons/links)
- Visual styling distinguishes success states from neutral/filtered states
- Consistent empty state presentation across all views
</success_criteria>

<output>
After completion, create `.planning/phases/01-ui-polish/01-02-SUMMARY.md`
</output>
