---
phase: 01-ui-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/components/common/ErrorState.tsx
  - client/src/components/Dashboard/Dashboard.tsx
  - client/src/components/Library/Library.tsx
  - client/src/components/Queue/Queue.tsx
  - client/src/components/History/History.tsx
  - client/src/components/Rules/Rules.tsx
  - client/src/components/Settings/Settings.tsx
  - client/src/lib/utils.ts
autonomous: true

must_haves:
  truths:
    - "User sees descriptive error message when API call fails"
    - "User sees retry button when error is recoverable"
    - "User sees helpful suggestion when error occurs"
  artifacts:
    - path: "client/src/components/common/ErrorState.tsx"
      provides: "Reusable error display component"
      exports: ["ErrorState"]
    - path: "client/src/lib/utils.ts"
      provides: "Error message mapping utility"
      contains: "getUserFriendlyMessage"
  key_links:
    - from: "client/src/components/Dashboard/Dashboard.tsx"
      to: "client/src/components/common/ErrorState.tsx"
      via: "import and render on isError"
      pattern: "isError.*ErrorState"
    - from: "client/src/components/Library/Library.tsx"
      to: "client/src/components/common/ErrorState.tsx"
      via: "import and render on isError"
      pattern: "isError.*ErrorState"
    - from: "client/src/components/Queue/Queue.tsx"
      to: "client/src/components/common/ErrorState.tsx"
      via: "import and render on isError"
      pattern: "isError.*ErrorState"
    - from: "client/src/components/History/History.tsx"
      to: "client/src/components/common/ErrorState.tsx"
      via: "import and render on isError"
      pattern: "isError.*ErrorState"
    - from: "client/src/components/Rules/Rules.tsx"
      to: "client/src/components/common/ErrorState.tsx"
      via: "import and render on isError"
      pattern: "isError.*ErrorState"
    - from: "client/src/components/Settings/Settings.tsx"
      to: "client/src/components/common/ErrorState.tsx"
      via: "import and render on isError"
      pattern: "isError.*ErrorState"
---

<objective>
Add comprehensive error state handling to all data-fetching views.

Purpose: Currently NO components handle `isError` from React Query - API failures show blank screens or undefined behavior. This creates a poor user experience and makes debugging difficult.

Output: All views display user-friendly error messages with retry options when API calls fail.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-ui-polish/01-RESEARCH.md

# Key existing code
@client/src/lib/utils.ts
@client/src/components/common/Toast.tsx
@client/src/components/Dashboard/Dashboard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorState component and error utility</name>
  <files>client/src/components/common/ErrorState.tsx, client/src/lib/utils.ts</files>
  <action>
Create a reusable ErrorState component in `client/src/components/common/ErrorState.tsx`:

```typescript
interface ErrorStateProps {
  error: Error | null;
  title?: string;
  retry?: () => void;
}
```

The component should:
- Display an AlertCircle icon from lucide-react in a ruby/red themed container
- Show a title (default: "Something went wrong")
- Show a user-friendly error message (not raw technical errors)
- Show a "Try Again" button when retry function is provided
- Match the existing empty state styling pattern (see EmptyState in Dashboard.tsx)

Add a `getUserFriendlyMessage(error: Error): string` function to `client/src/lib/utils.ts` that maps common errors:
- Network errors ("Network error", "ECONNREFUSED") -> "Unable to connect to the server. Please check your connection."
- Timeout errors ("timeout") -> "The request took too long. Please try again."
- 401/403 errors -> "You don't have permission to perform this action."
- 404 errors -> "The requested resource was not found."
- 500+ errors -> "The server encountered an error. Please try again later."
- Default -> The error message as-is (cleaned of technical details)

Use the existing styling patterns:
- Card container: `card p-12 text-center`
- Icon container: `w-16 h-16 mx-auto mb-4 rounded-2xl bg-ruby-500/10 flex items-center justify-center`
- Icon: `w-8 h-8 text-ruby-400`
- Title: `text-lg font-display font-semibold text-surface-200 mb-2`
- Message: `text-surface-400 mb-4`
- Button: Use existing Button component with variant="secondary"
  </action>
  <verify>
- File exists: `client/src/components/common/ErrorState.tsx`
- Exports ErrorState component
- `getUserFriendlyMessage` function exists in utils.ts
- TypeScript compiles: `cd /home/harry/projects/library-manager/client && npx tsc --noEmit`
  </verify>
  <done>ErrorState component created with proper styling and getUserFriendlyMessage utility function exists</done>
</task>

<task type="auto">
  <name>Task 2: Add error handling to Dashboard</name>
  <files>client/src/components/Dashboard/Dashboard.tsx</files>
  <action>
Update Dashboard.tsx to handle error states from ALL data queries:

1. Import ErrorState from `@/components/common/ErrorState`

2. Destructure `isError` and `error` from each useQuery hook:
   - `useStats()` - statsError, statsIsError
   - `useRecentActivity()` - activityError, activityIsError
   - `useUpcomingDeletions()` - deletionsError, deletionsIsError
   - `useRecommendations()` - recommendationsError, recommendationsIsError
   - `useUnraidStats()` - unraidError, unraidIsError

3. For the main stats section, if ANY critical query fails (stats, activity, deletions), show a full-page error state at the top of the dashboard with retry that refetches all queries.

4. For individual sections (Recent Activity, Upcoming Deletions, Recommendations, Storage Overview), handle errors locally within each card:
   - Replace the section content with an inline error state
   - Include retry button that calls the specific refetch function
   - Keep the section header visible so users know what failed

Example pattern for a section:
```tsx
{activityLoading ? (
  <LoadingSkeleton />
) : activityIsError ? (
  <ErrorState
    error={activityError}
    title="Failed to load activity"
    retry={refetchActivity}
  />
) : recentActivity && recentActivity.length > 0 ? (
  <ActivityList />
) : (
  <EmptyState />
)}
```
  </action>
  <verify>
- Dashboard.tsx imports ErrorState
- Each data section handles isError state
- TypeScript compiles without errors
- Manual test: Temporarily break an API endpoint to verify error state displays
  </verify>
  <done>Dashboard shows error states for failed API calls with retry options</done>
</task>

<task type="auto">
  <name>Task 3: Add error handling to remaining views</name>
  <files>client/src/components/Library/Library.tsx, client/src/components/Queue/Queue.tsx, client/src/components/History/History.tsx, client/src/components/Rules/Rules.tsx, client/src/components/Settings/Settings.tsx</files>
  <action>
Add error handling to each remaining view following the same pattern as Dashboard:

**Library.tsx:**
- Destructure `isError, error, refetch` from `useLibrary(filters)`
- Add error check after loading check in the main content area
- Show ErrorState with retry when library fetch fails
- Keep the filters bar visible so users can adjust search/filters

**Queue.tsx:**
- Destructure `isError, error, refetch` from `useDeletionQueue()`
- Add error check in the Queue List section
- Show ErrorState with retry when queue fetch fails
- Keep header and action buttons visible

**History.tsx:**
- Destructure `isError, error, refetch` from `useDeletionHistory(filters)`
- Add error check in the History List section
- Show ErrorState with retry when history fetch fails
- Keep filters visible

**Rules.tsx:**
- Check current structure and add error handling for `useRules()` query
- Show ErrorState with retry when rules fetch fails

**Settings.tsx:**
- Check current structure and add error handling for `useSettings()` query
- Show ErrorState with retry when settings fetch fails
- Critical: Settings may need special handling since users can't really "retry" easily

For each file:
1. Import ErrorState from `@/components/common/ErrorState`
2. Destructure isError and error from the query
3. Add error state rendering between loading and data checks
4. Provide refetch function to retry button
  </action>
  <verify>
- All listed files import ErrorState
- Each file handles isError from its primary query
- TypeScript compiles: `cd /home/harry/projects/library-manager/client && npx tsc --noEmit`
- Build succeeds: `cd /home/harry/projects/library-manager/client && npm run build`
  </verify>
  <done>All data-fetching views handle API errors gracefully with retry options</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compilation passes with no errors
2. Production build completes successfully
3. Each view (Dashboard, Library, Queue, History, Rules, Settings) has error handling
4. ErrorState component exists and is properly styled
5. getUserFriendlyMessage maps common errors to user-friendly messages
</verification>

<success_criteria>
- User sees descriptive error messages when any API call fails (not blank screens)
- User can retry failed operations with a single click
- Error messages are user-friendly, not technical jargon
- All views maintain consistent error presentation styling
</success_criteria>

<output>
After completion, create `.planning/phases/01-ui-polish/01-01-SUMMARY.md`
</output>
